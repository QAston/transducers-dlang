<!DOCTYPE html>
<html lang="en">
	<head>
	<meta charset="utf-8">
	<title>transduced - Transduced documentation</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="">
	<meta name="author" content="">

	<!-- styles -->
	<link href="bootDoc/assets/css/bootstrap.css" rel="stylesheet">
	<style type="text/css">
		body {
		padding-top: 60px;
		padding-bottom: 40px;
		}
		.sidebar-nav {
		padding: 9px 0;
		}
	</style>
	<link href="bootDoc/assets/css/bootstrap-responsive.css" rel="stylesheet">
	<link href="bootDoc/bootdoc.css" rel="stylesheet">

	<!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
		<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- fav and touch icons -->
	<link rel="shortcut icon" href="bootDoc/assets/ico/favicon.ico">
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="bootDoc/assets/ico/apple-touch-icon-114-precomposed.png">
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="bootDoc/assets/ico/apple-touch-icon-72-precomposed.png">
	<link rel="apple-touch-icon-precomposed" href="bootDoc/assets/ico/apple-touch-icon-57-precomposed.png">
	
	<!-- Introduce DDoc settings required by JavaScript -->
	<script type="text/javascript">
		var Title = 'transduced';
		var SourceRepository = 'http://github.com/QAston/transducers-dlang/tree/master/source';
		var PackageSeparator = '.';
	</script>
	
	<style type="text/css">
		.ddoc-icon-variable { background-image: url('bootDoc/ddoc-icons/var.png'); }
		.ddoc-icon-function { background-image: url('bootDoc/ddoc-icons/func.png'); }
		.ddoc-icon-property { background-image: url('bootDoc/ddoc-icons/property.png'); }
		.ddoc-icon-struct { background-image: url('bootDoc/ddoc-icons/struct.png'); }
		.ddoc-icon-class { background-image: url('bootDoc/ddoc-icons/class.png'); }
		.ddoc-icon-enum { background-image: url('bootDoc/ddoc-icons/enum.png'); }
		.ddoc-icon-template { background-image: url('bootDoc/ddoc-icons/template.png'); }
	</style>
	</head>

	<body>
	<!--
	JavaScript reaps the module list from this element.
	This is required for the MODULES macro to be reusable
	in a noscript element later.
	-->
	<ul id="module-list-source" class="hidden">
		
	<li class="sidebar-list-entry tree-leaf"><a href="transduced.package.html" title="transduced.package"><i class="icon-th"></i>transduced.package</a></li> 
	<li class="sidebar-list-entry tree-leaf"><a href="transduced.range.html" title="transduced.range"><i class="icon-th"></i>transduced.range</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="transduced.core.html" title="transduced.core"><i class="icon-th"></i>transduced.core</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="transduced.transducers.html" title="transduced.transducers"><i class="icon-th"></i>transduced.transducers</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="transduced.util.html" title="transduced.util"><i class="icon-th"></i>transduced.util</a></li>
	</ul>
	
	<div class="navbar navbar-fixed-top">
		<div class="navbar-inner">
			<div class="container-fluid">
				<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</a>
				<a class="brand" href="transduced.package.html">Transduced</a>
				<div class="nav-collapse">
					<ul class="nav">
						<li class="active"><a href="transduced.package.html">Reference</a></li>
					</ul>
					
					<form id="gotosymbol" class="navbar-search pull-left hidden">
						<input type="text" class="search-query" placeholder="Go to symbol in transduced" data-provide="typeahead" data-items="4">
					</form>
					
					<p class="navbar-text pull-right"><a href="https://github.com/QAston/transducers-dlang/">Github Page</a></p>
				</div><!--/.nav-collapse -->
			</div>
		</div>
	</div>

	<div class="container-fluid">
		<div class="row-fluid">
			<div class="span2">
				<div class="well sidebar-nav">
				<ul class="nav nav-list">
					<li id="module-list" class="nav-header sidebar-list-entry">Modules<li>
					<noscript>
						
	<li class="sidebar-list-entry tree-leaf"><a href="transduced.package.html" title="transduced.package"><i class="icon-th"></i>transduced.package</a></li> 
	<li class="sidebar-list-entry tree-leaf"><a href="transduced.range.html" title="transduced.range"><i class="icon-th"></i>transduced.range</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="transduced.core.html" title="transduced.core"><i class="icon-th"></i>transduced.core</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="transduced.transducers.html" title="transduced.transducers"><i class="icon-th"></i>transduced.transducers</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="transduced.util.html" title="transduced.util"><i class="icon-th"></i>transduced.util</a></li>
					</noscript>
					<li id="symbol-list" class="nav-header sidebar-list-entry hidden">transduced</li>
				</ul>
				</div><!--/.well -->
			</div><!--/span-->
			
			<div class="span10">
				<div class="row-fluid">
					<div class="span11">
						<ul id="module-breadcrumb" class="breadcrumb">
							<noscript><h1>transduced</h1></noscript>
						</ul>
						
					</div>
					<div class="span1 offset11">
						<a href="transduced.package.html"><img src="bootDoc/assets/img/icon-github.png" alt="Transduced"/></a>
					</div>
				</div>
				<div id="declaration-list">
					<!-- Generated by Ddoc from ..\source\transduced\package.d -->
<dl><p><h1>Transduced</h1>
<p>Implementation of sequential operations on <a href="http://dlang.org/phobos/std_range_primitives.html">InputRanges/OutputRanges</a> inspired by <a href="http://clojure.org/reference/transducers">Clojure transducers</a>, as presented on this <a href="https://www.youtube.com/watch?v=6mTbuzafcII">strange loop video</a>.</p>
<p>This library complements phobos with operations for transforming OutputRanges (eg. map, filter, take), but also allows using those same operations on InputRanges. Designed to integrate with any range code.</p>
<h2>Motivation</h2>
<p>Ever since I've learned about transducers in clojure I wanted to implement them in D, and so this library came to be. Turns out it's possible to port a concept relying so on dynamic typing to a statically typed language.
Resulting library explores various design possibilities which could be useful in phobos, like stack closures and allocating ranges. No idea if anyone would actually use this library, but hey - it was fun to develop.</p>
<h2>Comparison with phobos sequence transformations</h2>
Transducers are better than phobos sequence transformations in these ways:
<ul>
<li>
transducers allow working with OutputRanges while phobos range algorithms don't (except std.range.tee, but that doesn't allow composition - ie you don't get a modified output range out of it)
</li>
<li>
transducers extend the OutputRange concept with buffering and early termination, see <span class="inlinecode"><span class="symbol-target" id="transduced">&nbsp;</span><a class="symbol-link" href="#transduced">transduced</a>.core.isExtendedOutputRange</span>
</li>
<li>
transducers are objects which can be composed on their own, without specifying InputRange/OutputRange to apply them on
</li>
<li>
transducers are more reusable - could work on any sequential processing, not just plain ranges because they're independent of execution strategy (push/pull) and transformed type (eq. queues, ipc)
</li>
<li>
transducers provide different set of sequential operations (eg. flatMapper, taker with pred)
</li>
<li>
transducers can work with functors passed by value (callable structs for example), while phobos only works with functors passed by name (alias), which results in allocating data on heap <a href="http://forum.dlang.org/post/kpwbtskhnkkiwkdsfzby@forum.dlang.org"> allocating data on heap </a>
</li>
</ul>
Transducers are worse than phobos sequence transformations in the following ways:
<ul>
<li>
using transducers takes a bit more typing compared to range algorithms
</li>
<li>
transducers can't forward additional information about InputRanges like bidirectionality/forward ranges that can be forwarded by phobos sequence algorithms
</li>
<li>
some transducers allocate and own memory, while std ranges do not, therfore transducers can be a bit slower, but you can choose your allocator for those
</li>
<li>
transducers have more methods to inline, possibly resulting in more code bloat
</li>
<li>
transducers can't take inline delegates by name ("cannot access stack frame" compiler error, usually manifested as "can't find overload" because of template constraints), they can be only taken by value
</li>
</ul>
<ul>
Other differences:
<li>
when processing InputRanges transducers are lazy with respect to source range elements, each lazy step is generating all the output for that step at once; phobos functions are lazy with respect to generated output
</li>
</ul>
</p>
<p><h2>Differences from clojure transducers</h2>
<p>Basically everything is different except the core idea:
<ul>
<li>Transducers are objects instead of functions: different handling of early termination(flag on the object), completion (split between destructor and flush, flush can be called multiple times), no reducing function, etc.
<li>Design patterns/OOP terminology is used instead of mathematical terminology.
<li>Implementation has different constraints: statically typed using templates, cannot freely copy objects, cannot share references.
<li>Transduced adopts Dlang conventions and practices - while in clojure there are many possible transducible processes, in Dlang ExtendedOutputRanges encapsulate any possible process, so <span class="inlinecode"><span class="symbol-target" id="transduced">&nbsp;</span><a class="symbol-link" href="#transduced">transduced</a>.core.Putter</span> as an only process is enough.
</p>
</ul>
<h2>Usage examples</h2>
<pre class="d_code">    <span class="d_keyword">import</span> std.range;
    <span class="d_keyword">import</span> std.array;
    <span class="d_keyword">import</span> std.algorithm;

    <span class="d_comment">// silly little domain model
</span>    <span class="d_keyword">struct</span> Baggage
    {
        <span class="d_keyword">int</span> weight;
        <span class="d_keyword">bool</span> food;
        <span class="d_keyword">bool</span> ticking;
    }

    <span class="d_keyword">struct</span> BaggageWithLabel
    {
        <span class="d_keyword">int</span> weight;
        <span class="d_keyword">bool</span> food;
        <span class="d_keyword">bool</span> ticking;
        <span class="d_keyword">bool</span> heavy;
    }

    <span class="d_keyword">class</span> Plane
    {
        <span class="d_keyword">private</span> Appender!(BaggageWithLabel[]) baggages;
        <span class="d_keyword">this</span>()
        {
            baggages = appender!(BaggageWithLabel[]);
        }

        <span class="d_keyword">void</span> load(BaggageWithLabel stuff)
        {
            baggages.put(stuff);
        }

        BaggageWithLabel[] getBaggages()
        {
            <span class="d_keyword">return</span> baggages.data;
        }
    }

    <span class="d_comment">// transducers describing process of dealing with baggage
</span>    <span class="d_keyword">auto</span> stopWhenTicking = taker!((bag) =&gt; !bag.ticking);

    <span class="d_keyword">auto</span> filterNonFood = filterer!((bag) =&gt; !bag.food);

    <span class="d_keyword">auto</span> labelHeavy = mapper!((bag) =&gt; BaggageWithLabel(bag.weight, bag.food,
        bag.ticking, bag.weight &gt; 10));

    <span class="d_keyword">auto</span> ontoPallets = chunkMapper!((<span class="d_keyword">scope</span> BaggageWithLabel[] bagsView) =&gt; bagsView.dup)(3);

    <span class="d_comment">// revert ontoPallets transformation - just an excercise
</span>    <span class="d_keyword">auto</span> offPallets = flattener();

    <span class="d_comment">// compose a larger transducer from smaller ones
</span>    <span class="d_keyword">auto</span> baggageJob = comp(stopWhenTicking, filterNonFood, labelHeavy, ontoPallets,
        offPallets);

    <span class="d_keyword">auto</span> baggages = [
        Baggage(10, <span class="d_keyword">false</span>, <span class="d_keyword">false</span>), Baggage(5, <span class="d_keyword">true</span>, <span class="d_keyword">false</span>), Baggage(20, <span class="d_keyword">false</span>,
        <span class="d_keyword">false</span>), Baggage(5, <span class="d_keyword">false</span>, <span class="d_keyword">true</span>), Baggage(2, <span class="d_keyword">true</span>, <span class="d_keyword">false</span>), Baggage(2,
        <span class="d_keyword">false</span>, <span class="d_keyword">false</span>), Baggage(30, <span class="d_keyword">false</span>, <span class="d_keyword">false</span>)
    ];

    <span class="d_comment">// create an input range using a transducer
</span>    <span class="d_keyword">auto</span> lazyInputRange = baggages.transduceSource(baggageJob);
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isInputRange!(<span class="d_keyword">typeof</span>(lazyInputRange)));

    <span class="d_keyword">assert</span>(lazyInputRange.move().array() == [BaggageWithLabel(10, <span class="d_keyword">false</span>, <span class="d_keyword">false</span>,
        <span class="d_keyword">false</span>), BaggageWithLabel(20, <span class="d_keyword">false</span>, <span class="d_keyword">false</span>, <span class="d_keyword">true</span>)]);

    <span class="d_comment">// similar (but simpler, I'm lazy) job using phobos:
</span>    <span class="d_keyword">auto</span> lazilyInputRangeUsingPhobos = baggages.take(5)
        .map!((bag) =&gt; BaggageWithLabel(bag.weight, bag.food, bag.ticking, bag.weight &gt; 20));

    <span class="d_comment">// create an output range using transducers
</span>    Plane p = <span class="d_keyword">new</span> Plane();
    <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>(BaggageWithLabel) load = &amp;p.load;
    <span class="d_comment">// use the same transducer as for input range
</span>    <span class="d_keyword">auto</span> wrappedLoad = transduceSink!Baggage(baggageJob, load);

    <span class="d_comment">// use an output range
</span>    <span class="d_keyword">foreach</span> (Baggage b; baggages)
    {
        <span class="d_comment">// could check wrappedLoad.isDone here for early termination, but don't have to, can use extendedOutputRange just like regular one
</span>        std.range.put(wrappedLoad, b);
    }

    wrappedLoad.flush(); <span class="d_comment">// we're doing buffered transformations (ontoPallets), so we need to flush to get results
</span>
    <span class="d_keyword">assert</span>(p.getBaggages() == [BaggageWithLabel(10, <span class="d_keyword">false</span>, <span class="d_keyword">false</span>, <span class="d_keyword">false</span>),
        BaggageWithLabel(20, <span class="d_keyword">false</span>, <span class="d_keyword">false</span>, <span class="d_keyword">true</span>)]);
</pre>
<br><br>

<!--<h2>How this all works</h2>
What is a transducer
how it does what it does
how is it used
follow description of transducers in clojure?
<p><span class="inlinecode">transduced.core.Putter</span> - object wrapping an OutputRange, providing it with operations needed to implement transformations of sequential input: early termination and buffering (flush). Putter is itself an OutputRange. Wrapped OutputRange here represents a sequential process which we're manipulating. An example of that process is the process of building a new InputRange from an existing one. Each call to <span class="inlinecode">OutputRange.put</span> adds a new item to our newly created InputRange. Depending on how and when we call <span class="inlinecode">OutputRange.put</span>, we get different resulting sequences of items.</p>
<p>PutterDecorator is a struct which wraps a Decorated <span class="inlinecode">transduced.core.Putter</span> struct with input sequence transformation. The functionality is implemented inside <span class="inlinecode">PutterDecorator.put</span> and <span class="inlinecode">PutterDecorator.flush</span> by calling methods of a Decorated object:
<ul>
<li>forwarding no input to the decorated object - an example would be filter operation when based on a condition we either forward an input by calling <span class="inlinecode">Decorated.put</span> or we don't
<li>forwarding each given input by calling <span class="inlinecode">Decorated.put</span> - an example would be a map operation, which forwards transformed input
<li>forwarding more input than we're given - an example of that is flatten operation, where we merge given InputRanges together
<li>accumulating items - some transformations need to know about past inputs - an example of that is operation chunks, which agregates inputs into equally sized chunks. All accumulated items need to be processed on <span class="inlinecode">Decorated.flush</span>.
</ul>
</p>
<p>Transducer is a functor encapsulating sequence transformation description. For example: `auto transducer = mapper!((int x)=> x* 2)` is a transducer that doubles each given integer - the transducer object contains the description of that operation. Each transducer functor takes 1 argument - the possibly decorated <span class="inlinecode">transduced.core.Putter</span> object and wraps it with associated PutterDecorator object (in case of mapper <span class="inlinecode">transduced.transducers.Mapper</span>).</p>
<p>Transducers can be composed arbitrarily using <span class="inlinecode">transduced.transducer.comp</span> function, which returns a transducer composed of given transducers, applied one-after-another, which when applied behave like InputRange composition in phobos (which are also decorators).
<p>--></p>
</dl>

				</div>
				
				<hr>
				
				<footer class="pull-left">
					<p>Page generated with <a href="https://github.com/JakobOvrum/bootDoc">bootDoc</a>.</p>
				</footer>
				
				<footer class="pull-right">
					<p>&copy; Dariusz Antoniuk 2016</p>
				</footer>
			</div>
		</div>
	</div><!--/.fluid-container-->

	<!-- Bootstrap javascript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	<script src="bootDoc/assets/js/jquery.min.js"></script>
	<script src="bootDoc/assets/js/bootstrap.min.js"></script>
	
	<!-- bootDoc javascript
	================================================== -->
	<script src="bootDoc/bootdoc.js"></script>
	
	</body>
</html>
